<script type='text/javascript' src='framebuffer.js'></script>
<script type='text/javascript' src='particles.js'></script>
<script type='text/javascript' src='quad.js'></script>
<script type='text/javascript' src='cube.js'></script>
<script type='text/javascript' src='staticgeometry.js'></script>
<script type='text/javascript' src='camera.js'></script>
<script type='text/javascript' src='tessplane.js'></script>
<script type='text/javascript' src='gl-matrix-min.js'></script>

<script>
'use strict'

const shaderSource = {
	vertex: {
		test:
`#version 300 es
layout(location = 0) in vec2 a0;
out vec2 p;

void main()
{
	gl_Position = vec4(a0, 0.0, 1.0);
	p = a0.xy * 0.5 + 0.5;
}`,

		particleBasic:
`#version 300 es
layout(location = 0) in highp vec3 position;
layout(location = 1) in highp vec3 velocity;
out highp float point_size;
flat out int id;
uniform highp mat4 mvp;
//in highp int gl_VertexID;

void main()
{
	gl_Position = mvp * vec4(position, 1.0);
	point_size = gl_Position.w * 1.25;//32.0 / (position.z * 0.5 + 0.5 + 1.0);
	gl_PointSize = point_size;
	id = int(position.x * position.y * position.z * 12345934.0);//gl_VertexID
	//id = gl_VertexID;
}`,

		flat:
`#version 300 es
layout(location = 0) in highp vec3 position;
layout(location = 1) in highp vec3 normal;
layout(location = 2) in highp vec2 uv;
out highp vec3 n;
uniform highp mat4 mvp, mv;

void main()
{
	gl_Position = mvp * vec4(position, 1.0);
	n = (mv * vec4(normal, 0.0)).xyz;
}`,
	},

	fragment: {
		test:
`#version 300 es
precision highp int;
precision highp float;
layout(location = 0) out lowp vec4 frag_color;
uniform highp vec2 screen_size;
uniform highp vec2 inverse_screen_size;
uniform highp float time;
uniform sampler2D screen;
in vec2 p;

void main()
{
	frag_color = texture(screen, p);
}`,

		particleFlat:
`#version 300 es
precision highp int;
precision highp float;
layout(location = 0) out lowp vec4 frag_color;
in highp float point_size;
flat in int id;

vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d){return a + b * cos(6.283185307179586 * (c * t + d));}

void main()
{
	highp float alpha = 0.5 * clamp(min(1.0, point_size * 0.5 - length(gl_PointCoord * point_size - point_size * 0.5)), 0.0, 1.0);
	if (alpha <= 0.0)
		discard;
	vec3 col = vec3(1.0) - palette(float(id) / 50000.0, vec3(` + Math.random() + `, ` + Math.random() + `, ` + Math.random() + `), vec3(` + Math.random() + `,` + Math.random() + `,` + Math.random() + `), vec3(` + Math.random() + `,` + Math.random() + `,` + Math.random() + `), vec3(` + Math.random() + `,` + Math.random() + `,` + Math.random() + `));
	frag_color = vec4(col * alpha, alpha);
}`,

		flat:
`#version 300 es
layout(location = 0) out lowp vec4 frag_color;
precision highp int;
precision highp float;
in vec3 n;

void main()
{
	frag_color = vec4(normalize(n) * 0.5 + 0.5, 0.0);
}`,

		color:
`#version 300 es
layout(location = 0) out lowp vec4 frag_color;
precision highp int;
precision highp float;
in vec3 n;
uniform vec4 color;

void main()
{
	frag_color = color;
}`,

		colorSpace:
`#version 300 es
precision highp float;
vec3 LinearTosRGB(vec3 c)
{
	return vec3(
		c.r <= 0.0031308 ? 12.92 * c.r : 1.055 * pow(c.r, 1.0 / 2.4) - 0.055,
		c.g <= 0.0031308 ? 12.92 * c.g : 1.055 * pow(c.g, 1.0 / 2.4) - 0.055,
		c.b <= 0.0031308 ? 12.92 * c.b : 1.055 * pow(c.b, 1.0 / 2.4) - 0.055);
}

vec3 sRGBToLinear(vec3 c)
{
	return vec3(
		c.r <= 0.04045 ? c.r / 12.92 : pow(c.r / 1.055 + 0.055 / 1.055, 2.4),
		c.g <= 0.04045 ? c.g / 12.92 : pow(c.g / 1.055 + 0.055 / 1.055, 2.4),
		c.b <= 0.04045 ? c.b / 12.92 : pow(c.b / 1.055 + 0.055 / 1.055, 2.4));
}`
	}
}

let shaderPrograms = {
	'test': {
		'fragment': ['test'],
		'vertex': ['test'],
		'uniforms': {
			'screen_size': null,
			'inverse_screen_size': null,
			'time': null,
			'screen': null
		}
	},

	'particles0': {
		'fragment': ['particleFlat'],
		'vertex': ['particleBasic'],
		'uniforms': {
			'mvp': null
		}
	},

	'flat': {
		'fragment': ['flat'],
		'vertex': ['flat'],
		'uniforms': {
			'mvp': null,
			'mv': null,
		}
	},

	'color': {
		'fragment': ['color'],
		'vertex': ['flat'],
		'uniforms': {
			'mvp': null,
			'mv': null,
			'color': null,
		}
	},

	/*'flow0': {
		'vertex': ['flow0'],
		'uniforms': {
			'mvp': null,
			'mv': null,
		},
		'varyings': ['position', 'velocity']
	}*/
}

let canvas = null
let gl = null
let frame = 0
let time = 0.0

let pointLights = []

function compileShader(shaderSource, shaderType) {
	if (shaderType == 'vertex')
		shaderType = gl.VERTEX_SHADER
	else if (shaderType == 'fragment')
		shaderType = gl.FRAGMENT_SHADER

	let shader = gl.createShader(shaderType)
	gl.shaderSource(shader, shaderSource)
	gl.compileShader(shader)

	if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.log(gl.getShaderInfoLog(shader))
		gl.deleteShader(shader)
		return null
  }

	return shader
}

function createLightClusters(camera) {
	const x = 16
	const y = 9
	const z = 32

	for (let i in pointLights) {
		let r = pointLights[i].color.max()
	}
}

function linkProgram(shaders, varyings) {
	let program = gl.createProgram()
	for (const shader in shaders) {
		if (!shaders[shader]) {
			console.log(shader)
		}
		else {
			gl.attachShader(program, shaders[shader])
		}
	}

	if (varyings != undefined) {
		gl.transformFeedbackVaryings(program, varyings, gl.INTERLEAVED_ATTRIBS)
	}

	gl.linkProgram(program)

	if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.log(gl.getProgramInfoLog(program))
			gl.deleteProgram(program)
			return null
  }

	return program
}

let particles = null
let plane = null

function load() {
	const compiledShader = { vertex: {}, fragment: {}}

	for (const shaderType in shaderSource) {
		for (const name in shaderSource[shaderType]) {
			compiledShader[shaderType][name] = compileShader(shaderSource[shaderType][name], shaderType)
		}
	}

	for (const program in shaderPrograms) {
		let shaders = []
		for (const shaderType in shaderSource) {
			for (const shader in shaderPrograms[program][shaderType]) {
				shaders.push(compiledShader[shaderType][shaderPrograms[program][shaderType][shader]])
			}
		}

		shaderPrograms[program].program = linkProgram(shaders, program.varyings)
		if (!shaderPrograms[program].program) {
			return false
		}

		for (const uniform in shaderPrograms[program].uniforms) {
			shaderPrograms[program].uniforms[uniform] = gl.getUniformLocation(shaderPrograms[program].program, uniform)
		}
	}

	Quad.init()
	Cube.init()
	plane = new TessPlane(6)
	particles = new Particles(50000)

	for (let i = 0; i < 4096; ++i) {
		pointLights.push({
			position: vec3.fromValues(Math.random() * 100.0 - 50.0, Math.random() * 50.0, Math.random() * 100.0 - 50.0),
			color: vec3.fromValues(Math.random() * 10.0, Math.random() * 10.0, Math.random() * 10.0)
		})
	}

	return true
}

let camera = new Camera(Math.PI / 4.0, 1.0, 0.1, 100.0)

function renderLoop(frameTime) {
	let dt = (frameTime - time) * 0.001
	time = frameTime * 0.001

	//

	camera.aspect = canvas.offsetWidth / canvas.offsetHeight
	//camera.focalLength = 8.0
	camera.updateProjection()
	camera.lookAt(vec3.fromValues(Math.cos(time * 0.1) * 5.0, 2.5, Math.sin(time * 0.1) * 5.0), vec3.fromValues(0.0, 0.0, 0.0), vec3.fromValues(0.0, 1.0, 0.0))
	//camera.lookAt(vec3.fromValues(0.0, 0.0, -5.0), vec3.fromValues(0.0, 0.0, 0.0), vec3.fromValues(0.0, 1.0, 0.0))
	camera.update()

	Framebuffer.bind()
	gl.clearColor(1.0, 1.0, 1.0, 0.0)
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)

	gl.enable(gl.CULL_FACE)
	gl.useProgram(shaderPrograms['color'].program)
	gl.uniformMatrix4fv(shaderPrograms['color'].uniforms['mvp'], false, camera.mvp)
	gl.uniformMatrix4fv(shaderPrograms['color'].uniforms['mv'], false, camera.view)
	gl.uniform4f(shaderPrograms['color'].uniforms['color'], 0.0, 0.0, 0.0, 0.0);
	Cube.drawOutlines()

	gl.enable(gl.DEPTH_TEST)
	gl.useProgram(shaderPrograms['color'].program)
	gl.uniformMatrix4fv(shaderPrograms['color'].uniforms['mvp'], false, camera.mvp)
	gl.uniformMatrix4fv(shaderPrograms['color'].uniforms['mv'], false, camera.view)
	gl.uniform4f(shaderPrograms['color'].uniforms['color'], 1.0, 0.0, 0.0, 0.0);
	plane.draw()
	gl.disable(gl.DEPTH_TEST)
	gl.disable(gl.CULL_FACE)

	/*gl.enable(gl.BLEND)
	gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)
	// gl.blendFunc(gl.ONE, gl.ONE)
	gl.useProgram(shaderPrograms['particles0'].program)
	gl.uniformMatrix4fv(shaderPrograms['particles0'].uniforms['mvp'], false, camera.mvp)
	particles.draw()
	gl.disable(gl.BLEND)*/

	//

	gl.bindFramebuffer(gl.FRAMEBUFFER, null)
	gl.drawBuffers([gl.BACK])
	gl.viewport(0.0, 0.0, canvas.width, canvas.height)

	gl.activeTexture(gl.TEXTURE0)
	gl.bindTexture(gl.TEXTURE_2D, Framebuffer.textureHdr)

	gl.useProgram(shaderPrograms['test'].program)
	gl.uniform1f(shaderPrograms['test'].uniforms['time'], time)
	gl.uniform2f(shaderPrograms['test'].uniforms['inverse_screen_size'], 1.0 / canvas.width, 1.0 / canvas.height)
	gl.uniform2f(shaderPrograms['test'].uniforms['screen_size'], canvas.width, canvas.height)
	gl.uniform1i(shaderPrograms['test'].uniforms['screen'], 0)
	Quad.draw()

	++frame
	window.requestAnimationFrame(renderLoop)
}

function resize() {
	canvas.width = window.innerWidth
	canvas.height = window.innerHeight

	Framebuffer.init(canvas.width, canvas.height)
}

window.addEventListener('load', () => {
	canvas = document.createElement('canvas')
	canvas.style.width = '100%'
	canvas.style.height = '100%'
	canvas.style.top = '0'
	canvas.style.left = '0'
	canvas.style.position = 'fixed'
	//canvas.style.padding = '0'
	//canvas.style.zIndex = '-1'

	gl = canvas.getContext('webgl2', {alpha: false, depth: false, stencil: false, antialias: false})
	if (gl == null) {
		alert('WebGL 2.0 not supported apparently.\n' +
			'Check if it is enabled if you think this should work.')
		return
	}

	console.log(gl.getSupportedExtensions())

	resize()
	window.addEventListener('resize', resize)

	document.body.appendChild(canvas)

	if (!load()) {
		alert('Loading failed.\n' +
			'This shouldn\'t happen. It\'s probably a bug.')
		return
	}

	renderLoop(0.0)
})
</script>
