<script type='text/javascript' src='vec2.js'></script>
<script type='text/javascript' src='vec3.js'></script>
<script type='text/javascript' src='vec4.js'></script>
<script>

const fullScreenTriangle = [
	0, 127,
	-127, -2,
	127, -2
]

let shaderSource = {
	// vertex shaders
	'vertex': {
		'test':
			'#version 300 es\n' +
			'layout(location = 0) in vec2 a0;\n' +
			'void main()\n' +
			'{\n' +
				'gl_Position = vec4(a0, 0.0, 1.0);\n' +
			'}\n',
	},
	// fragment shaders
	'fragment': {
		'test':
			'#version 300 es\n' +
			'layout(location = 0) out lowp vec4 frag_color;\n' +
			'uniform highp vec2 screen_size;\n' +
			'uniform highp vec2 inverse_screen_size;\n' +
			'uniform highp float time;\n' +
			'void main()\n' +
			'{\n' +
				'frag_color = vec4(gl_FragCoord.xy * inverse_screen_size, cos(time) * 0.5 + 0.5, 0.0);\n' +
			'}\n',
	}
}

let shaderPrograms = {
	'test': {
		'fragment': ['test'],
		'vertex': ['test'],
		'uniforms': {
			'screen_size': null,
			'inverse_screen_size': null,
			'time': null,
		}
	},
}

const staticGeometry = {
	add: function(id, data) {
		const SIZE_IN_MB = 16

		if (!this.vbo) {
			this.indexData = {}
			this.vbo = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo)
			gl.bufferData(gl.ARRAY_BUFFER, SIZE_IN_MB * 1048576, gl.STATIC_DRAW)
			this.lastOffset = 0
		}

		gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo)
		gl.bufferSubData(gl.ARRAY_BUFFER, this.lastOffset, data)

		this.indexData[id] = {
			offset: this.lastOffset,
			size: data.byteLength
		}

		this.lastOffet += data.byteLength

		return this.indexData[id]
	},

	get: function(id) {
		return this.indexData[id]
	},

	bind: function() {
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo)
	}
}

let canvas = null
let gl = null
let frame = 0
let time = 0.0

class Particles {
	constructor() {
		//this.buffer = Float64Array(8 * maxParticles)
		//this.buffer = Float32Array(8 * maxParticles)

		this.buffers = []
		this.buffers.push(gl.createBuffer())
		this.buffers.push(gl.createBuffer())

		gl.bindBuffer(buffers[0], gl.ARRAY_BUFFER)
		gl.bufferData(gl.ARRAY_BUFFER, maxParticles * 4 * 8, gl.DYNAMIC_DRAW)

		gl.bindBuffer(buffers[1], gl.ARRAY_BUFFER)
		gl.bufferData(gl.ARRAY_BUFFER, maxParticles * 4 * 8, gl.DYNAMIC_DRAW)
	}
}

let quad = {
	init: function() {
		let data = staticGeometry.add('fullScreenTriangle', new Int8Array(fullScreenTriangle))
		delete fullScreenTriangle

		this.vao = gl.createVertexArray()
		gl.bindVertexArray(this.vao)
		gl.vertexAttribPointer(0, 2, gl.BYTE, false, 0, data.offset)
		gl.enableVertexAttribArray(0)
	},

	render: function() {
		gl.bindVertexArray(this.vao)
		gl.drawArrays(gl.TRIANGLES, 0, 3)
	}
}

function compileShader(shaderSource, shaderType) {
	if (shaderType == 'vertex')
		shaderType = gl.VERTEX_SHADER
	else if (shaderType == 'fragment')
		shaderType = gl.FRAGMENT_SHADER

	let shader = gl.createShader(shaderType)
	gl.shaderSource(shader, shaderSource)
	gl.compileShader(shader)

	if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.log(gl.getShaderInfoLog(shader))
		gl.deleteShader(shader)
		return null
  }

	return shader
}

function linkProgram(shaders, attribs) {
	let program = gl.createProgram()
	for (let shader in shaders) {
		gl.attachShader(program, shaders[shader])
	}

	gl.linkProgram(program)

	if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.log(gl.getProgramInfoLog(program))
			gl.deleteProgram(program)
			return null
  }

	return program
}

function load() {
	let compiledShader = {}

	for (let shaderType in shaderSource) {
		compiledShader[shaderType] = {}
		for (let shader in shaderSource[shaderType]) {
			compiledShader[shaderType][shader] = compileShader(shaderSource[shaderType][shader], shaderType)
			if (!compiledShader[shaderType][shader]) {
				return false
			}
		}
	}

	for (let program in shaderPrograms) {
		let shaders = []
		for (let shaderType in shaderSource) {
			for (let shader in shaderPrograms[program][shaderType]) {
				shaders.push(compiledShader[shaderType][shaderPrograms[program][shaderType][shader]])
			}
		}
		shaderPrograms[program].program = linkProgram(shaders)
		if (!shaderPrograms[program].program) {
			return false
		}

		for (let uniform in shaderPrograms[program].uniforms) {
			shaderPrograms[program].uniforms[uniform] = gl.getUniformLocation(shaderPrograms[program].program, uniform)
		}
	}

	quad.init()

	return true
}

function renderLoop(frameTime) {
	let dt = (frameTime - time) * 0.001
	time = frameTime * 0.001

	gl.viewport(0, 0, canvas.width, canvas.height)

	gl.useProgram(shaderPrograms['test'].program)
	gl.uniform1f(shaderPrograms['test'].uniforms['time'], time)
	gl.uniform2f(shaderPrograms['test'].uniforms['inverse_screen_size'], 1.0 / canvas.width, 1.0 / canvas.height)
	gl.uniform2f(shaderPrograms['test'].uniforms['screen_size'], canvas.width, canvas.height)
	quad.render()

	++frame
	window.requestAnimationFrame(renderLoop)
}

function resize() {
	canvas.width = window.innerWidth
	canvas.height = window.innerHeight
}

window.addEventListener('load', () => {
	canvas = document.createElement('canvas')
	canvas.style.width = '100%'
	canvas.style.height = '100%'
	canvas.style.top = '0'
	canvas.style.left = '0'
	canvas.style.position = 'fixed'
	//canvas.style.padding = '0'
	//canvas.style.zIndex = '-1'

	gl = canvas.getContext('webgl2', {alpha: false, depth: false, stencil: false, antialias: false})
	if (gl == null) {
		alert('WebGL 2.0 not supported apparently.\n' +
			'Check if it is enabled if you think this should work.')
		return
	}

	resize()
	window.addEventListener('resize', resize)

	document.body.appendChild(canvas)

	if (!load()) {
		alert('Loading failed.\n' +
			'This shouldn\'t happen. It\'s probably a bug.')
		return
	}

	renderLoop(0.0)
})
</script>
