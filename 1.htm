<script type='text/javascript' src='vec2.js'></script>
<script type='text/javascript' src='vec3.js'></script>
<script type='text/javascript' src='vec4.js'></script>
<script type='text/javascript' src='mat4.js'></script>
<script>
'use strict'

let shaderSource = {
	// vertex shaders
	'vertex': {
		'test':
			'#version 300 es\n' +
			'layout(location = 0) in vec2 a0;\n' +
			'void main()\n' +
			'{\n' +
				'gl_Position = vec4(a0, 0.0, 1.0);\n' +
			'}\n',

		'particleBasic':
			'#version 300 es\n' +
			'layout(location = 0) in highp vec3 position;\n' +
			'layout(location = 1) in highp vec3 velocity;\n' +
			'out highp float point_size;\n' +
			'flat out int id;\n' +
			'uniform highp mat4 mvp;\n' +
			//'in highp int gl_VertexID;\n' +
			'void main()\n' +
			'{\n' +
				'gl_Position = vec4(position, 1.0);\n' +
				'point_size = 32.0 / (position.z * 0.5 + 0.5 + 1.0);\n' +
				'gl_PointSize = point_size;\n' +
				'id = int(position.x * position.y * position.z * 12345934.0);//gl_VertexID\n' +
				//'id = gl_VertexID;\n' +
			'}\n',
	},
	// fragment shaders
	'fragment': {
		'test':
			'#version 300 es\n' +
			'precision highp int;\n' +
			'precision highp float;\n' +
			'layout(location = 0) out lowp vec4 frag_color;\n' +
			'uniform highp vec2 screen_size;\n' +
			'uniform highp vec2 inverse_screen_size;\n' +
			'uniform highp float time;\n' +
			'void main()\n' +
			'{\n' +
				'frag_color = vec4(gl_FragCoord.xy * inverse_screen_size, cos(time) * 0.5 + 0.5, 0.0);\n' +
			'}\n',

		'particleFlat':
			'#version 300 es\n' +
			'precision highp int;\n' +
			'precision highp float;\n' +
			'layout(location = 0) out lowp vec4 frag_color;\n' +
			'in highp float point_size;\n' +
			'flat in int id;\n' +

			'vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d){return a + b * cos(6.283185307179586 * (c * t + d));}\n' +

			'void main()\n' +
			'{\n' +
				'//if (length(gl_PointCoord * 2.0 - 1.0) > 1.0)\n' +
					'//discard; \n' +
				'highp float alpha = clamp(min(1.0, point_size * 0.5 - length(gl_PointCoord * point_size - point_size * 0.5)), 0.0, 1.0);\n' +
				'vec3 col = palette(fract(float(id) / 232.234643), vec3(.03453212, .2359, .34966), vec3(.745674567,.223452345,.75564), vec3(.123412345,.7385,.12354346), vec3(.23456234,.3456234,.1346));\n' +
				'frag_color = vec4(col * alpha, alpha);\n' +
			'}\n',
	}
}

let shaderPrograms = {
	'test': {
		'fragment': ['test'],
		'vertex': ['test'],
		'uniforms': {
			'screen_size': null,
			'inverse_screen_size': null,
			'time': null,
		}
	},

	'particles0': {
		'fragment': ['particleFlat'],
		'vertex': ['particleBasic'],
		'uniforms': {
			'mvp': null
		}
	}
}

const staticGeometry = {
	add: function(id, data) {
		const SIZE_IN_MB = 16

		if (!this.vbo) {
			this.indexData = {}
			this.vbo = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo)
			gl.bufferData(gl.ARRAY_BUFFER, SIZE_IN_MB * 1048576, gl.STATIC_DRAW)
			this.lastOffset = 0
		}

		gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo)
		gl.bufferSubData(gl.ARRAY_BUFFER, this.lastOffset, data)

		this.indexData[id] = {
			offset: this.lastOffset,
			size: data.byteLength
		}

		this.lastOffet += data.byteLength

		return this.indexData[id]
	},

	get: function(id) {
		return this.indexData[id]
	},

	bind: function() {
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo)
	}
}

let canvas = null
let gl = null
let frame = 0
let time = 0.0

class Particles {
	constructor(nParticles) {
		this.nParticles = nParticles
		let goldenAngle = 2.3999632297286533222315555066336	// precision! xD
		let altAngle = Math.PI * 2.0 - goldenAngle
		let buffer = new Float32Array(nParticles * 6)	// position + velocity

		for (let i = 1; i <= nParticles; ++i) {
			let theta = (goldenAngle * i) % Math.PI
			let phi = goldenAngle * i
			let r = Math.pow(i / nParticles, 1.0 / 3.0) 

			let bi = (i - 1) * 6
			
			buffer[bi + 0] = r * Math.sin(theta) * Math.cos(phi)
			buffer[bi + 1] = r * Math.sin(theta) * Math.sin(phi)
			buffer[bi + 2] = r * Math.cos(theta)

			console.log(buffer[bi + 0], buffer[bi + 1], buffer[bi + 2])

			buffer[bi + 3] = 0.0	//velocity[0]
			buffer[bi + 4] = 0.0	//velocity[1]
			buffer[bi + 5] = 0.0	//velocity[2]
		}

		this.vbo = gl.createBuffer()
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo)
		gl.bufferData(gl.ARRAY_BUFFER, buffer, gl.DYNAMIC_COPY)

		this.vao = gl.createVertexArray()
		gl.bindVertexArray(this.vao)
		gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 24, 0)
		gl.enableVertexAttribArray(0)
		gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 24, 12)
		gl.enableVertexAttribArray(1)
	}

	draw() {
		gl.bindVertexArray(this.vao)
		gl.drawArrays(gl.POINTS, 0, this.nParticles)
	}
}

let quad = {
	init: function() {
		const fullScreenTriangle = [
			0, 127,
			-127, -2,
			127, -2
		]

		let data = staticGeometry.add('fullScreenTriangle', new Int8Array(fullScreenTriangle))

		this.vao = gl.createVertexArray()
		gl.bindVertexArray(this.vao)
		gl.vertexAttribPointer(0, 2, gl.BYTE, false, 0, data.offset)
		gl.enableVertexAttribArray(0)
	},

	draw: function() {
		gl.bindVertexArray(this.vao)
		gl.drawArrays(gl.TRIANGLES, 0, 3)
	}
}

function compileShader(shaderSource, shaderType) {
	if (shaderType == 'vertex')
		shaderType = gl.VERTEX_SHADER
	else if (shaderType == 'fragment')
		shaderType = gl.FRAGMENT_SHADER

	let shader = gl.createShader(shaderType)
	gl.shaderSource(shader, shaderSource)
	gl.compileShader(shader)

	if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.log(gl.getShaderInfoLog(shader))
		gl.deleteShader(shader)
		return null
  }

	return shader
}

function linkProgram(shaders, attribs) {
	let program = gl.createProgram()
	for (let shader in shaders) {
		gl.attachShader(program, shaders[shader])
	}

	gl.linkProgram(program)

	if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.log(gl.getProgramInfoLog(program))
			gl.deleteProgram(program)
			return null
  }

	return program
}

let particles = null

function load() {
	let compiledShader = {}

	for (let shaderType in shaderSource) {
		compiledShader[shaderType] = {}
		for (let shader in shaderSource[shaderType]) {
			compiledShader[shaderType][shader] = compileShader(shaderSource[shaderType][shader], shaderType)
			if (!compiledShader[shaderType][shader]) {
				return false
			}
		}
	}

	for (let program in shaderPrograms) {
		let shaders = []
		for (let shaderType in shaderSource) {
			for (let shader in shaderPrograms[program][shaderType]) {
				shaders.push(compiledShader[shaderType][shaderPrograms[program][shaderType][shader]])
			}
		}
		shaderPrograms[program].program = linkProgram(shaders)
		if (!shaderPrograms[program].program) {
			return false
		}

		for (let uniform in shaderPrograms[program].uniforms) {
			shaderPrograms[program].uniforms[uniform] = gl.getUniformLocation(shaderPrograms[program].program, uniform)
		}
	}

	quad.init()
	particles = new Particles(10000)

	return true
}

function renderLoop(frameTime) {
	let dt = (frameTime - time) * 0.001
	time = frameTime * 0.001

	gl.viewport(0, 0, canvas.width, canvas.height)

	//

	gl.useProgram(shaderPrograms['test'].program)
	gl.uniform1f(shaderPrograms['test'].uniforms['time'], time)
	gl.uniform2f(shaderPrograms['test'].uniforms['inverse_screen_size'], 1.0 / canvas.width, 1.0 / canvas.height)
	gl.uniform2f(shaderPrograms['test'].uniforms['screen_size'], canvas.width, canvas.height)
	quad.draw()

	gl.enable(gl.BLEND)
	gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)
	gl.useProgram(shaderPrograms['particles0'].program)
	particles.draw()
	gl.disable(gl.BLEND)

	//

	++frame
	window.requestAnimationFrame(renderLoop)
}

function resize() {
	canvas.width = window.innerWidth
	canvas.height = window.innerHeight
}

window.addEventListener('load', () => {
	canvas = document.createElement('canvas')
	canvas.style.width = '100%'
	canvas.style.height = '100%'
	canvas.style.top = '0'
	canvas.style.left = '0'
	canvas.style.position = 'fixed'
	//canvas.style.padding = '0'
	//canvas.style.zIndex = '-1'

	gl = canvas.getContext('webgl2', {alpha: false, depth: false, stencil: false, antialias: false})
	if (gl == null) {
		alert('WebGL 2.0 not supported apparently.\n' +
			'Check if it is enabled if you think this should work.')
		return
	}

	resize()
	window.addEventListener('resize', resize)

	document.body.appendChild(canvas)

	if (!load()) {
		alert('Loading failed.\n' +
			'This shouldn\'t happen. It\'s probably a bug.')
		return
	}

	renderLoop(0.0)
})
</script>
