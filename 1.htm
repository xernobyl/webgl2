<script type='text/javascript' src='framebuffer.js'></script>
<script type='text/javascript' src='particles.js'></script>
<script type='text/javascript' src='quad.js'></script>
<script type='text/javascript' src='staticgeometry.js'></script>
<script type='text/javascript' src='vec2.js'></script>
<script type='text/javascript' src='vec3.js'></script>
<script type='text/javascript' src='vec4.js'></script>
<script type='text/javascript' src='mat4.js'></script>
<script type='text/javascript' src='gl-matrix-min.js'></script>
<script>
'use strict'

let shaderSource = {
	// vertex shaders
	'vertex': {
		'test':
			'#version 300 es\n' +
			'layout(location = 0) in vec2 a0;\n' +
			'out vec2 p;\n' +
			'void main()\n' +
			'{\n' +
				'gl_Position = vec4(a0, 0.0, 1.0);\n' +
				'p = a0.xy * 0.5 + 0.5;\n' +
			'}\n',

		'particleBasic':
			'#version 300 es\n' +
			'layout(location = 0) in highp vec3 position;\n' +
			'layout(location = 1) in highp vec3 velocity;\n' +
			'out highp float point_size;\n' +
			'flat out int id;\n' +
			'uniform highp mat4 mvp;\n' +
			//'in highp int gl_VertexID;\n' +
			'void main()\n' +
			'{\n' +
				'gl_Position = mvp * vec4(position, 1.0);\n' +
				'point_size = gl_Position.w * 10.0;//32.0 / (position.z * 0.5 + 0.5 + 1.0);\n' +
				'gl_PointSize = point_size;\n' +
				'id = int(position.x * position.y * position.z * 12345934.0);//gl_VertexID\n' +
				//'id = gl_VertexID;\n' +
			'}\n',
	},
	// fragment shaders
	'fragment': {
		'test':
			'#version 300 es\n' +
			'precision highp int;\n' +
			'precision highp float;\n' +
			'layout(location = 0) out lowp vec4 frag_color;\n' +
			'uniform highp vec2 screen_size;\n' +
			'uniform highp vec2 inverse_screen_size;\n' +
			'uniform highp float time;\n' +
			'uniform sampler2D screen;\n' +
			'in vec2 p;\n' +
			'void main()\n' +
			'{\n' +
				'frag_color = vec4(p, 0.0, 0.0) * texture(screen, p);\n' +
			'}\n',

		'particleFlat':
			'#version 300 es\n' +
			'precision highp int;\n' +
			'precision highp float;\n' +
			'layout(location = 0) out lowp vec4 frag_color;\n' +
			'in highp float point_size;\n' +
			'flat in int id;\n' +

			'vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d){return a + b * cos(6.283185307179586 * (c * t + d));}\n' +

			'void main()\n' +
			'{\n' +
				'//if (length(gl_PointCoord * 2.0 - 1.0) > 1.0)\n' +
					'//discard; \n' +
				'highp float alpha = clamp(min(1.0, point_size * 0.5 - length(gl_PointCoord * point_size - point_size * 0.5)), 0.0, 1.0);\n' +
				'vec3 col = vec3(1.0);//palette(fract(float(id) / 232.234643), vec3(.03453212, .2359, .34966), vec3(.745674567,.223452345,.75564), vec3(.123412345,.7385,.12354346), vec3(.23456234,.3456234,.1346));\n' +
				'frag_color = vec4(col * alpha, alpha);\n' +
			'}\n',
	}
}

let shaderPrograms = {
	'test': {
		'fragment': ['test'],
		'vertex': ['test'],
		'uniforms': {
			'screen_size': null,
			'inverse_screen_size': null,
			'time': null,
			'screen': null
		}
	},

	'particles0': {
		'fragment': ['particleFlat'],
		'vertex': ['particleBasic'],
		'uniforms': {
			'mvp': null
		}
	}
}

let canvas = null
let gl = null
let frame = 0
let time = 0.0

function compileShader(shaderSource, shaderType) {
	if (shaderType == 'vertex')
		shaderType = gl.VERTEX_SHADER
	else if (shaderType == 'fragment')
		shaderType = gl.FRAGMENT_SHADER

	let shader = gl.createShader(shaderType)
	gl.shaderSource(shader, shaderSource)
	gl.compileShader(shader)

	if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.log(gl.getShaderInfoLog(shader))
		gl.deleteShader(shader)
		return null
  }

	return shader
}

function linkProgram(shaders, attribs) {
	let program = gl.createProgram()
	for (let shader in shaders) {
		gl.attachShader(program, shaders[shader])
	}

	gl.linkProgram(program)

	if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.log(gl.getProgramInfoLog(program))
			gl.deleteProgram(program)
			return null
  }

	return program
}

let particles = null

function load() {
	let compiledShader = {}

	for (let shaderType in shaderSource) {
		compiledShader[shaderType] = {}
		for (let shader in shaderSource[shaderType]) {
			compiledShader[shaderType][shader] = compileShader(shaderSource[shaderType][shader], shaderType)
			if (!compiledShader[shaderType][shader]) {
				return false
			}
		}
	}

	for (let program in shaderPrograms) {
		let shaders = []
		for (let shaderType in shaderSource) {
			for (let shader in shaderPrograms[program][shaderType]) {
				shaders.push(compiledShader[shaderType][shaderPrograms[program][shaderType][shader]])
			}
		}
		shaderPrograms[program].program = linkProgram(shaders)
		if (!shaderPrograms[program].program) {
			return false
		}

		for (let uniform in shaderPrograms[program].uniforms) {
			shaderPrograms[program].uniforms[uniform] = gl.getUniformLocation(shaderPrograms[program].program, uniform)
		}
	}

	quad.init()
	particles = new Particles(10000)

	return true
}

function renderLoop(frameTime) {
	let dt = (frameTime - time) * 0.001
	time = frameTime * 0.001

	//

	let aspect = canvas.offsetWidth / canvas.offsetHeight
	let near = 0.1
	let far = 100.0
	let fov = Math.PI / 2.0

	/*let projection = Mat4.projection(fov, aspect, near, far)
	let view = Mat4.lookAt(new Vec3(Math.cos(time * 0.1) * 2.5, 0.0, Math.sin(time * 0.1) * 2.5), new Vec3(0.0, 0.0, 0.0), new Vec3(0.0, 1.0, 0.0))
	let mvp = Mat4.mul(view, projection)*/

	let projection = mat4.create()
	mat4.perspective(projection, fov, aspect, near, far)

	let view = mat4.create()
	mat4.lookAt(view,
		[Math.cos(time * 0.1) * 2.5, 0.0, Math.sin(time * 0.1) * 2.5],
		[0.0, 0.0, 0.0],
		[0.0, 1.0, 0.0])

	let mvp = mat4.create()
	mat4.multiply(mvp, projection, view)

	framebuffer.bind()

	gl.enable(gl.BLEND)
	gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)
	gl.useProgram(shaderPrograms['particles0'].program)
	gl.uniformMatrix4fv(shaderPrograms['particles0'].uniforms['mvp'], false, mvp)
	//gl.uniformMatrix4fv(shaderPrograms['particles0'].uniforms['mvp'], false, mvp.mat)
	particles.draw()
	gl.disable(gl.BLEND)

	//

	gl.bindFramebuffer(gl.FRAMEBUFFER, null)
	gl.drawBuffers([gl.BACK])
	gl.viewport(0.0, 0.0, canvas.width, canvas.height)

	/*gl.enable(gl.BLEND)
	gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)
	gl.useProgram(shaderPrograms['particles0'].program)
	gl.uniformMatrix4fv(shaderPrograms['particles0'].uniforms['mvp'], false, mvp)
	//gl.uniformMatrix4fv(shaderPrograms['particles0'].uniforms['mvp'], false, mvp.mat)
	particles.draw()*/

	gl.activeTexture(gl.TEXTURE0)
	gl.bindTexture(gl.TEXTURE_2D, framebuffer.tex[0])

	gl.useProgram(shaderPrograms['test'].program)
	gl.uniform1f(shaderPrograms['test'].uniforms['time'], time)
	gl.uniform2f(shaderPrograms['test'].uniforms['inverse_screen_size'], 1.0 / canvas.width, 1.0 / canvas.height)
	gl.uniform2f(shaderPrograms['test'].uniforms['screen_size'], canvas.width, canvas.height)
	gl.uniform1i(shaderPrograms['test'].uniforms['screen'], 0)
	quad.draw()

	++frame
	window.requestAnimationFrame(renderLoop)
}

function resize() {
	canvas.width = window.innerWidth
	canvas.height = window.innerHeight

	framebuffer.init(canvas.width, canvas.height)
}

window.addEventListener('load', () => {
	canvas = document.createElement('canvas')
	canvas.style.width = '100%'
	canvas.style.height = '100%'
	canvas.style.top = '0'
	canvas.style.left = '0'
	canvas.style.position = 'fixed'
	//canvas.style.padding = '0'
	//canvas.style.zIndex = '-1'

	gl = canvas.getContext('webgl2', {alpha: false, depth: false, stencil: false, antialias: false})
	if (gl == null) {
		alert('WebGL 2.0 not supported apparently.\n' +
			'Check if it is enabled if you think this should work.')
		return
	}

	resize()
	window.addEventListener('resize', resize)

	document.body.appendChild(canvas)

	if (!load()) {
		alert('Loading failed.\n' +
			'This shouldn\'t happen. It\'s probably a bug.')
		return
	}

	renderLoop(0.0)
})
</script>
